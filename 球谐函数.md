# Spherical Harmonic

## 定义

### 官方定义



**球谐函数**是[拉普拉斯方程](https://zh.wikipedia.org/wiki/拉普拉斯方程)的[球坐标系](https://zh.wikipedia.org/wiki/球坐标系)形式解的角度部分。

![image-20240724101927279](https://raw.githubusercontent.com/eatdreamcat/PicGo-01/main/image-20240724101927279.png)

![](https://raw.githubusercontent.com/eatdreamcat/PicGo-01/main/image-20240724102026102.png)

![image-20240724102407292](https://raw.githubusercontent.com/eatdreamcat/PicGo-01/main/image-20240724102407292.png)



球谐函数实际上是在球坐标系下由一组基函数组成的，且具有一下性质：

- 正交性：基函数两两正交（线性无关）
- 归一化：在单位球面上积分为1（很适合用于表示概率密度）
- 旋转不变性：粗暴的理解为投影和逆投影是一致的



### 非官方定义

假设三维空间中有一个向量 $\vec{v}$ , 坐标表示为 $\{2,3,5\}$. 我们可以使用一组基向量  $\vec{i}$, $\vec{j}$, $\vec{k}$ 的加权和来表示:
$$
\vec{v} = 2\vec{i}+3\vec{j}+5\vec{k}
$$
 $\vec{i}$, $\vec{j}$, $\vec{k}$ 此三维空间中的一组正交基，在这个空间中的任意向量，都可以由这三个基向量的线性组合来表示，且这个表示是唯一的。（即任意一个基向量都无法通过另外两个基向量的线性组合来表示）



由于球谐函数是由一组线性无关的基函数组成的，因此可以把球谐函数认为是一个无限维的空间系，基函数则为维度坐标系，因此在这个空间系中的任何一个向量，都可以用这组基函数和系数的线性组合唯一表示。



### 基函数表达式

![image-20240724105904357](https://raw.githubusercontent.com/eatdreamcat/PicGo-01/main/image-20240724105904357.png)



## 渲染应用



在现实世界中的光照信息，也可以理解为是一组无穷维的向量数据，但是实际计算机模拟中，通常也只模拟有限个维度来进行近似。



假如在空间中的一个点，我们想计算出这个点接收到的四面八方的光能总量，实际上就是对这个点做球面积分去计算各个方向**$d\omega$**的**$Radiance$**总量，也就是求出这个点的**$Irradiance$**。



空间中的每一个点，都可以求出自己的$Irradiance$，然后场景着色的时候，可以去拿$Irradiance$来当作光源数据进行着色。



但是实际在对某个着色微元进行着色时，我们需要算的是**$n·l$**之后的**$Irradiance$**，然后再通过**bxdf**去算出反射到观察方向的比例。



### 球谐空间系转换



前面引申定义可以把球谐函数认为是一个空间坐标系，而空间中某一点的**$Irradiance$**是一个无穷维的向量数据，我们可以把这个数据用球谐空间系来表示，这样并不会改变向量本身携带的信息。



> 例如，对于世界坐标系下三维空间中的向量$\{0,1,0\}$,它永远表示一个竖直向上的向量，当我们把这个向量由世界坐标转换到相机坐标时，它只是系数变了，但是代表的方向数据是不变的。



因此，实际上，我们就是把**$Irradiance$**向量做了一个空间系的转换，**$Irradiance$**是由多个维度的基矢量线性组合而成（*这里指的采样，但是采样具有一定随机性，所以这里的基矢量并非严格意义的线性无关的基矢量*）。因此可以看成是先对各个分量进行空间系转换再进行线性组合。



**那么球谐空间系的转换怎么做呢？**



实际上就是做投影。



例如我们将一个模型空间的向量，转换到世界空间的向量，用矩阵的计算可以表示成下面的式子：
$$
\begin{bmatrix}
x_{world}\\
y_{world}\\
z_{world}
\end{bmatrix}=
\begin{bmatrix}
m00 &m01 &m02\\
m10 &m11 &m12\\
m20 &m21 &m22
\end{bmatrix} ·
\begin{bmatrix}x_{local}\\y_{local}\\z_{local}\end{bmatrix}
$$
其中$\{m00,m10,m20\},\{m01,m11,m21\},\{m02,m12,m22\}$分别表示世界空间的基矢量$\vec{i},\vec{j},\vec{k}$。
$$
x_{world} = x_{local}*m00 + y_{local}*m10 + z_{local}*m20
$$
可以看出新坐标系下的分量，分别由原坐标系的向量投影到各个基矢量得出。
$$
pxx_{local} = x_{local}*m00\\
pyx_{local} = y_{local}*m10\\
pzx_{local} = z_{local}*m20\\
x_{world} = pxx_{local} + pyx_{local} + pzx_{local}
$$


现在，假设有一盏点灯在空间中，我想要计算空间中某一点的**$Irradiance$**,这里先使用最简单暴力的均匀采样，例如我希望使用10个维度的数据来近似这个无穷维的$Irradiance$,那么我就对这个球面进行10次均匀采样，每一次采样都得到一个本地坐标系的分量记为$R_{local}^{i}(i=0...10)$，现在对这个$R_{local}^{i}(i=0...10)$投影到球谐坐标系的各个基矢量上，然后累加起来就得到球谐空间系表示的**$Irradiance$**。



这个过程可以用下面的式子来展示：

1. $f(normal, light) = Radiance$​
2. $coefficient = SH_{basic}(normal) * f(normal, light)$​
3. $f(normal, light) = coefficient * SH_{basic}(normal)$





那么伪代码可以表示为：

```c#
const int Level = 3; // 这里表示要用前几阶球谐
const int CoefficientCount = (Level)^2;
// RGB分量都得算
Vector4[] Coefficients = new Vector4[CoefficientCount];
foreach(var light in lights)
{
    for(int sampleIndex = 0; sampleIndex < 10; ++ sampleIndex)
    {
        var sampleDirection = GetDirection(sampleIndex);
        var sampleWeight = GetSampleWeight(sampleIndex);
        var radiance = SampleLight(light, sampleDirection) * sampleWeight;
        for (int c = 0; c < CoefficientCount; ++c)
        {
            Cofficients[c] += GetBasic(sampleDirection, c) * radiance;
        }
        
    }
}
```



在求出系数之后，实际着色时，就只需要传入**normal**给基函数，然后乘以系数就可以反推出对应的**$Radiance$**。



![image-20240724143718823](https://raw.githubusercontent.com/eatdreamcat/PicGo-01/main/image-20240724143718823.png)

从上图的基函数表达式可以看出，有常量部分和表达式部分，对于常量部分，我们可以直接在cpu端计算好。



